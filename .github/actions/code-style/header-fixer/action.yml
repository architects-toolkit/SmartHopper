name: "Header Fixer"
description: "Check or fix C# file headers to match .editorconfig header template"
inputs:
  mode:
    description: "Operation mode: fix, check, or soft-check"
    required: false
    default: "check"
runs:
  using: "composite"
  steps:
    - name: Process C# file headers
      shell: bash
      env:
        GITHUB_EVENT_NAME: ${{ github.event_name }}
        GITHUB_EVENT_PATH: ${{ github.event_path }}
      run: |
        echo "Header Fixer Debug: mode=${{ inputs.mode }}, event=$GITHUB_EVENT_NAME"
        # Determine files to process: changed in PR or all .cs in src/
        if [ "$GITHUB_EVENT_NAME" = "pull_request" ] && [ -f "$GITHUB_EVENT_PATH" ]; then
          BASE_SHA=$(jq -r .pull_request.base.sha < "$GITHUB_EVENT_PATH")
          HEAD_SHA=$(jq -r .pull_request.head.sha < "$GITHUB_EVENT_PATH")
          FILES=$(git diff --name-only "$BASE_SHA" "$HEAD_SHA" -- '*.cs' || true)
        else
          # Fallback to all .cs files under src/
          FILES=$(find src -type f -name '*.cs')
        fi
        echo "Files to process: length=${#FILES[@]}"
        # If no files, skip
        if [ -z "$FILES" ]; then
          echo "No C# files to process"
          exit 0
        fi
        ERR=0
        FAILED_FILES=()
        for file in $FILES; do
          if [ -f "$file" ]; then
            # Skip auto-generated files
            if head -n 20 "$file" | grep -q '<auto-generated>'; then
              echo "Skipping auto-generated file $file"
              continue
            fi

            # Get year
            year=$(grep -m1 '^ \* Copyright' "$file" | grep -oE '[0-9]{4}' || true)
            # echo "Extracted year for $file: $year"
            [ -z "$year" ] && year=$(date +%Y)
            
            # Header template lines
            HEADER_LINES_ARRAY=(
              "/*"
              " * SmartHopper - AI-powered Grasshopper Plugin"
              " * Copyright (C) $year Marc Roca Musach"
              " *"
              " * This library is free software; you can redistribute it and/or"
              " * modify it under the terms of the GNU Lesser General Public"
              " * License as published by the Free Software Foundation; either"
              " * version 3 of the License, or (at your option) any later version."
              " */"
              ""
            )
            HEADER_LINE_COUNT=${#HEADER_LINES_ARRAY[@]}

            # Compare header per-line ignoring year
            # echo "Comparing header for $file"
            mismatch=0
            mismatch_line=0
            for ((i=0; i<HEADER_LINE_COUNT; i++)); do
              TEMPLATE_LINE=${HEADER_LINES_ARRAY[i]}
              FILE_LINE=$(sed -n "$((i+1))p" "$file")
              TEMPLATE_CAN=$(echo "$TEMPLATE_LINE" | sed -E 's/(Copyright \(C\) )[0-9]{4}/\1####/')
              CURRENT_CAN=$(echo "$FILE_LINE" | sed -E 's/(Copyright \(C\) )[0-9]{4}/\1####/')
              if [[ "$TEMPLATE_CAN" != "$CURRENT_CAN" ]]; then
                mismatch=1
                mismatch_line=$((i+1))
                break
              fi
            done
            
            # echo "Header mismatch flag for $file: $mismatch"
            # Process header mismatch
            if (( mismatch == 1 )); then
              if [ "${{ inputs.mode }}" = "fix" ]; then
                echo "Updating header in $file"
                # Extract content after header template
                CONTENT=$(tail -n +$((HEADER_LINE_COUNT + 1)) "$file")
                
                # Prepare header
                NEW_HEADER=$(printf "%s\n" "${HEADER_LINES_ARRAY[@]}")
                
                # Write new file with header and content first
                echo -e "$NEW_HEADER\n\n$CONTENT" > "$file"
                
                # Now analyze the file after insertion to fix any comment issues
                # Get the content after the header in the updated file
                MODIFIED_CONTENT=$(tail -n +$((HEADER_LINE_COUNT + 1)) "$file")
                
                # Analyze comment blocks and balance them intelligently
                OPEN_COUNT=$(grep -o '/\*' <<< "$MODIFIED_CONTENT" | wc -l)
                CLOSE_COUNT=$(grep -o '\*/' <<< "$MODIFIED_CONTENT" | wc -l)
                
                NEEDS_UPDATE=0
                FIXED_CONTENT="$MODIFIED_CONTENT"
                
                # Check for unbalanced comments
                if [ $OPEN_COUNT -ne $CLOSE_COUNT ]; then
                  NEEDS_UPDATE=1
                  if [ $OPEN_COUNT -lt $CLOSE_COUNT ]; then
                    # More closing than opening - we need to add opening comments
                    if echo "$FIXED_CONTENT" | head -n 5 | grep -q '^[[:space:]]*\*'; then
                      # Find the first line with a * pattern
                      LINE_NUM=1
                      while IFS= read -r line; do
                        if [[ "$line" =~ ^[[:space:]]*\* ]]; then
                          break
                        fi
                        ((LINE_NUM++))
                      done <<< "$FIXED_CONTENT"
                      
                      # Split content to insert /* before first * line
                      BEFORE_COMMENT=$(echo "$FIXED_CONTENT" | head -n $((LINE_NUM-1)))
                      COMMENT_AND_AFTER=$(echo "$FIXED_CONTENT" | tail -n +$LINE_NUM)
                      
                      # Recombine with /* added
                      if [ -n "$BEFORE_COMMENT" ]; then
                        FIXED_CONTENT="${BEFORE_COMMENT}"$'\n'"/*"$'\n'"${COMMENT_AND_AFTER}"
                      else
                        FIXED_CONTENT="/*"$'\n'"${COMMENT_AND_AFTER}"
                      fi
                      echo "Added missing comment opening /* before line $LINE_NUM"
                    else
                      # No clear comment structure, add /* at beginning
                      FIXED_CONTENT="/*"$'\n'"$FIXED_CONTENT"
                      echo "Added missing comment opening /* at beginning"
                    fi
                  elif [ $OPEN_COUNT -gt $CLOSE_COUNT ]; then
                    # More opening than closing - add a closing comment at the end
                    FIXED_CONTENT="$FIXED_CONTENT"$'\n'"*/"
                    echo "Added missing comment closing */ at the end"
                  fi
                fi
                
                # Update the file if we made changes to the content
                if [ $NEEDS_UPDATE -eq 1 ]; then
                  echo -e "$NEW_HEADER\n\n$FIXED_CONTENT" > "$file"
                  echo "Fixed comment structure imbalance in $file"
                fi
              elif [ "${{ inputs.mode }}" = "soft-check" ]; then
                # emit a non-blocking warning
                echo "::warning file=$file::Header mismatch in $file (run with mode=fix to auto-fix)"
              elif [ "${{ inputs.mode }}" = "check" ]; then
                # Collect failed files and line for summary report
                FAILED_FILES+=("$file:$mismatch_line")
                ERR=1
              fi
            fi
          fi
        done
        # Summarize failures in check mode
        if [ "${{ inputs.mode }}" = "check" ] && [ ${#FAILED_FILES[@]} -ne 0 ]; then
          echo "❌ Header validation failed for the following files (file:line):"
          for entry in "${FAILED_FILES[@]}"; do
            path=${entry%%:*}
            ln=${entry##*:}
            echo "  - $path (line $ln)"
          done
          echo "Run with mode=fix to automatically update headers"
        elif [ "${{ inputs.mode }}" = "check" ]; then
          echo "✅ All header validations passed"
        fi
        exit $ERR
