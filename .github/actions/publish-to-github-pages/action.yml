name: 'Publish Hash Manifest to GitHub Pages'
description: 'Publishes provider hash manifest to GitHub Pages directory in main branch'
inputs:
  hash-file:
    description: 'Path to the hash manifest JSON file'
    required: true
  version:
    description: 'Version string (e.g., 1.2.3 or 1.2.3-alpha)'
    required: true
  pages-directory:
    description: 'Directory path for GitHub Pages files (relative to repo root)'
    required: false
    default: '.github/pages/hashes'
  update-latest:
    description: 'Whether to update latest.json (auto-detected for stable versions if empty)'
    required: false
    default: 'auto'
  github-token:
    description: 'GitHub token for committing to main branch'
    required: true
  repository:
    description: 'GitHub repository (owner/repo)'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Publish Hash Manifest
      shell: pwsh
      run: |
        # Validate and sanitize inputs
        $version = "${{ inputs.version }}"
        $hashFile = "${{ inputs.hash-file }}"
        $pagesDir = "${{ inputs.pages-directory }}"
        $updateLatestInput = "${{ inputs.update-latest }}"
        $repository = "${{ inputs.repository }}"
        
        # Validate version format
        if ([string]::IsNullOrWhiteSpace($version)) {
          Write-Host "##[error] Version cannot be empty"
          exit 1
        }
        if ($version -notmatch '^[0-9]+\.[0-9]+(\.[0-9]+)?(-[a-zA-Z0-9\.\-]+)?$') {
          Write-Host "##[error] Invalid version format: '$version'"
          exit 1
        }
        
        # Validate repository format
        if ([string]::IsNullOrWhiteSpace($repository)) {
          Write-Host "##[error] Repository cannot be empty"
          exit 1
        }
        if ($repository -notmatch '^[a-zA-Z0-9_\-]+/[a-zA-Z0-9_\-\.]+$') {
          Write-Host "##[error] Invalid repository format: '$repository'. Expected 'owner/repo'"
          exit 1
        }
        
        # Validate and sanitize pages directory to prevent path traversal
        if ([string]::IsNullOrWhiteSpace($pagesDir)) {
          Write-Host "##[error] Pages directory cannot be empty"
          exit 1
        }
        $pagesDir = $pagesDir -replace '\.\.[\\/]', ''
        if ($pagesDir -match '\.\.' -or $pagesDir -match '^[\\/]') {
          Write-Host "##[error] Invalid pages directory (potential path traversal): '$pagesDir'"
          exit 1
        }
        
        # Validate update-latest input
        if ($updateLatestInput -notin @('auto', 'true', 'false', '')) {
          Write-Host "##[error] Invalid update-latest value: '$updateLatestInput'. Must be 'auto', 'true', or 'false'"
          exit 1
        }
        
        Write-Host "Publishing hash manifest to GitHub Pages"
        Write-Host "  Version: $version"
        Write-Host "  Hash file: $hashFile"
        Write-Host "  Pages directory: $pagesDir"
        Write-Host "  Repository: $repository"
        
        # Verify hash file exists and is not empty
        # Handle both absolute and relative paths
        $resolvedHashFile = $hashFile
        if (!(Test-Path $resolvedHashFile)) {
          # Try looking in current directory if relative path doesn't work
          $resolvedHashFile = Join-Path (Get-Location) $hashFile
          if (!(Test-Path $resolvedHashFile)) {
            Write-Host "##[error] Hash file '$hashFile' not found in current directory or root!"
            Write-Host "##[error] Current directory: $(Get-Location)"
            Write-Host "##[error] Files in current directory:"
            Get-ChildItem -Filter "*.json" | ForEach-Object { Write-Host "  - $($_.Name)" }
            exit 1
          }
        }
        $hashFile = $resolvedHashFile

        # Cache hash file in runner temp before git operations (git stash/checkout can remove it)
        $tempHashPath = Join-Path $env:RUNNER_TEMP (Split-Path $hashFile -Leaf)
        Copy-Item $hashFile -Destination $tempHashPath -Force
        $hashFile = $tempHashPath

        $fileInfo = Get-Item $hashFile -ErrorAction Stop
        if ($fileInfo.Length -eq 0) {
          Write-Host "##[error] Hash file is empty!"
          exit 1
        }
        
        # Configure git
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
        # Ensure we're on main branch with timeout and error handling
        Write-Host ""
        Write-Host "Checking out main branch..."
        try {
          # Check repository state before operations
          $gitStatus = git status --porcelain 2>&1
          if ($LASTEXITCODE -ne 0) {
            throw "Failed to check git status: $gitStatus"
          }
          if ($gitStatus) {
            Write-Host "##[warning] Working directory not clean, stashing changes"
            git stash --include-untracked 2>&1 | Out-Null
            if ($LASTEXITCODE -ne 0) {
              throw "Failed to stash changes"
            }
          }
          
          # Fetch with native PowerShell git
          Write-Host "Fetching from origin..."
          git fetch origin main 2>&1 | Out-Null
          if ($LASTEXITCODE -ne 0) {
            throw "git fetch failed with exit code $LASTEXITCODE"
          }
          
          # Checkout main
          Write-Host "Checking out main branch..."
          git checkout main 2>&1 | Out-Null
          if ($LASTEXITCODE -ne 0) {
            throw "git checkout failed with exit code $LASTEXITCODE"
          }
          
          # Pull latest
          Write-Host "Pulling latest changes..."
          git pull origin main 2>&1 | Out-Null
          if ($LASTEXITCODE -ne 0) {
            throw "git pull failed with exit code $LASTEXITCODE"
          }
        } catch {
          Write-Host "##[error] Git operation failed: $_"
          Write-Host "##[error] Repository may be in an inconsistent state. Manual cleanup may be required."
          exit 1
        }
        
        # Create pages directory structure
        Write-Host ""
        Write-Host "Creating pages directory structure..."
        New-Item -ItemType Directory -Force -Path $pagesDir | Out-Null
        
        # Copy hash file with version-specific name (always override)
        $versionHashPath = Join-Path $pagesDir "$version.json"
        Copy-Item $hashFile -Destination $versionHashPath -Force
        Write-Host "Copied hash manifest to: $versionHashPath"
        
        # Determine if we should update latest.json
        # Improved regex to handle version formats like 1.0.0-alpha.1, 1.0.0-beta.2+build.123
        $isStable = $version -notmatch '-(alpha|beta|rc|dev)[\.\-]?[\d\w\.]*'
        $shouldUpdateLatest = $false
        
        if ($updateLatestInput -eq "auto") {
          $shouldUpdateLatest = $isStable
          if ($isStable) {
            Write-Host "Auto-detected stable version, will update latest.json"
          } else {
            Write-Host "Auto-detected prerelease version, will NOT update latest.json"
          }
        } elseif ($updateLatestInput -eq "true") {
          $shouldUpdateLatest = $true
          Write-Host "Forced update of latest.json"
        } else {
          Write-Host "Skipping latest.json update (disabled)"
        }
        
        if ($shouldUpdateLatest) {
          $latestHashPath = Join-Path $pagesDir "latest.json"
          Copy-Item $hashFile -Destination $latestHashPath -Force
          Write-Host "Updated latest.json"
        }
        
        # Create or update index page
        Write-Host ""
        Write-Host "Creating index page..."
        $indexContent = @"
        <!DOCTYPE html>
        <html>
        <head>
          <title>SmartHopper Provider Hash Repository</title>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <style>
            body { 
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
              max-width: 900px; 
              margin: 50px auto; 
              padding: 20px;
              line-height: 1.6;
              color: #333;
            }
            h1 { 
              color: #2c3e50;
              border-bottom: 3px solid #3498db;
              padding-bottom: 10px;
            }
            h2 {
              color: #34495e;
              margin-top: 30px;
            }
            .version { 
              margin: 8px 0;
              padding: 8px;
              border-radius: 4px;
              transition: background-color 0.2s;
            }
            .version:hover {
              background-color: #f8f9fa;
            }
            .stable { 
              border-left: 4px solid #27ae60;
              padding-left: 12px;
            }
            .prerelease { 
              border-left: 4px solid #f39c12;
              padding-left: 12px;
            }
            .stable a { color: #27ae60; font-weight: 600; }
            .prerelease a { color: #f39c12; }
            a { text-decoration: none; }
            a:hover { text-decoration: underline; }
            .badge {
              display: inline-block;
              padding: 2px 8px;
              border-radius: 3px;
              font-size: 0.85em;
              margin-left: 8px;
              font-weight: 500;
            }
            .badge-stable { background-color: #d4edda; color: #155724; }
            .badge-prerelease { background-color: #fff3cd; color: #856404; }
            .info {
              background-color: #e7f3ff;
              border-left: 4px solid #3498db;
              padding: 15px;
              margin: 20px 0;
              border-radius: 4px;
            }
            .loading {
              color: #7f8c8d;
              font-style: italic;
            }
          </style>
        </head>
        <body>
          <h1>üîê SmartHopper Provider Hash Repository</h1>
          
          <div class="info">
            <p><strong>Purpose:</strong> This repository contains SHA-256 hash manifests for SmartHopper provider DLLs.</p>
            <p>These hashes are used to verify the integrity and authenticity of provider assemblies at runtime.</p>
          </div>
          
          <h2>üì¶ Available Versions</h2>
          <div id="versions" class="loading">Loading versions...</div>
          
          <script>
            fetch('https://api.github.com/repos/${repository}/contents/${pagesDir}')
              .then(r => {
                if (!r.ok) throw new Error('Failed to fetch versions');
                return r.json();
              })
              .then(files => {
                const container = document.getElementById('versions');
                const jsonFiles = files.filter(f => f.name.endsWith('.json'));
                
                if (jsonFiles.length === 0) {
                  container.innerHTML = '<p>No versions available yet.</p>';
                  container.className = '';
                  return;
                }
                
                container.innerHTML = '';
                container.className = '';
                
                jsonFiles
                  .sort((a, b) => {
                    // Put latest.json first
                    if (a.name === 'latest.json') return -1;
                    if (b.name === 'latest.json') return 1;
                    // Then sort by version descending
                    return b.name.localeCompare(a.name, undefined, { numeric: true, sensitivity: 'base' });
                  })
                  .forEach(f => {
                    const div = document.createElement('div');
                    const a = document.createElement('a');
                    const rawUrl = 'https://raw.githubusercontent.com/${repository}/main/${pagesDir}/' + f.name;
                    a.href = rawUrl;
                    a.textContent = f.name.replace('.json', '');
                    
                    const isLatest = f.name === 'latest.json';
                    const isStable = !f.name.match(/(alpha|beta|rc|dev)/);
                    
                    div.className = 'version ' + (isStable || isLatest ? 'stable' : 'prerelease');
                    div.appendChild(a);
                    
                    if (isLatest) {
                      const badge = document.createElement('span');
                      badge.className = 'badge badge-stable';
                      badge.textContent = 'Latest Stable';
                      div.appendChild(badge);
                    } else if (!isStable) {
                      const badge = document.createElement('span');
                      badge.className = 'badge badge-prerelease';
                      badge.textContent = 'Prerelease';
                      div.appendChild(badge);
                    }
                    
                    container.appendChild(div);
                  });
              })
              .catch(err => {
                const container = document.getElementById('versions');
                container.innerHTML = '<p style="color: #e74c3c;">Error loading versions: ' + err.message + '</p>';
                container.className = '';
              });
          </script>
        </body>
        </html>
        "@
        $indexPath = Join-Path (Split-Path $pagesDir -Parent) "index.html"
        Set-Content -Path $indexPath -Value $indexContent -Encoding UTF8
        Write-Host "Created/updated index page at: $indexPath"
        
        # Commit and push to main with error handling
        Write-Host ""
        Write-Host "Committing changes..."
        try {
          $parentDir = Split-Path $pagesDir -Parent
          git add $parentDir 2>&1 | Out-Null
          if ($LASTEXITCODE -ne 0) {
            throw "git add failed with exit code $LASTEXITCODE"
          }
          
          # Sanitize commit message to prevent injection
          $commitMessage = "Add provider hashes for $version"
          $commitMessage = $commitMessage -replace '[`$]', ''
          
          # Try to commit using native git
          git commit -m $commitMessage 2>&1 | Out-Null
          $commitExitCode = $LASTEXITCODE
          
          if ($commitExitCode -eq 0) {
            # Commit succeeded, now push
            Write-Host "Pushing to main branch..."
            git push origin main 2>&1 | Out-Null
            
            if ($LASTEXITCODE -ne 0) {
              throw "git push failed with exit code $LASTEXITCODE"
            }
            
            Write-Host ""
            Write-Host "##[notice] Hash manifest published successfully!"
            Write-Host "##[notice] Version hash: https://raw.githubusercontent.com/${repository}/main/${pagesDir}/$version.json"
            if ($shouldUpdateLatest) {
              Write-Host "##[notice] Latest hash: https://raw.githubusercontent.com/${repository}/main/${pagesDir}/latest.json"
            }
          } elseif ($commitExitCode -eq 1) {
            # Exit code 1 typically means no changes to commit
            Write-Host "##[warning] No changes to commit (hash already exists, overridden)"
          } else {
            throw "git commit failed with exit code $commitExitCode"
          }
        } catch {
          Write-Host "##[error] Failed to commit and push changes: $_"
          Write-Host "##[error] Repository may be in an inconsistent state. Manual cleanup may be required."
          exit 1
        }
